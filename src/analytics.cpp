/*
 * analytics.cpp
 *
 *  Created on: Feb 25, 2016
 *      Author: eba
 */

#include <iostream>
#include <string>
#include <cstring>
#include <vector>
#include <mutex>
#include <memory>
#include <thread>
#include <condition_variable>
#include <chrono>
#include <functional>
#include <sstream>

#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>

#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/buffer.h>
#include <openssl/hmac.h>

#include <zlib.h>

#include <auxiliary/json11.hpp>

#include <orx.h>

#include <analytics.h>
#include <remote.h>
#include <platform.h>
#include <scroll_ext/config_utils.hpp>
#include <orx_utilities.h>

using namespace json11;

#ifdef SANDBOX
std::string url_prefix = "http://sandbox-api.gameanalytics.com/v2/";
const char * game_key = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
const char * secret_key = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
#else
std::string url_prefix = "http://api.gameanalytics.com/v2/";
const char * game_key = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
const char * secret_key = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
#endif

std::string url_init() {
    return url_prefix + game_key + "/init";
}

std::string url_events() {
    return url_prefix + game_key + "/events";
}

void orxConfigX_SetJson(const char * key, Json::object json) {
    orxConfig_SetString(key, Json(json).dump().c_str());
}

Json::object orxConfigX_GetJson(const char * key) {
    std::string err;
    return Json::parse(orxConfig_GetString(key), err).object_items();
}

template <class T, class ...Ts>
std::string join(const char * sep, T && t, Ts && ... ts) {
    std::stringstream ss;
    ss << t;
    int dummy[] = {(ss << sep, ss << ts, 0)...};
    return ss.str();
}

const char * sdk_version = "rest api v2";

void analytics_worker(platform_info);

enum analytics_status {
    INITIALIZING, ACTIVE, DISABLED, DISCONNECTED
};

struct game_session {
    std::string session_id;
    orxU64 session_num;
    orxU64 local_session_start_ts;
    std::string custom_01;
    std::string build_desc;
};

struct analytics_session {
    orxS64 ts_offset;
};

struct event_details {
    orxU64 unadjusted_ts;
    Json::object details;
};

struct raw_event {
    game_session session;
    event_details details;
};

typedef Json::object baked_event;
typedef Json::array baked_event_queue_t;
typedef std::vector<raw_event> raw_event_queue_t;
typedef std::vector<std::function<void()>> action_queue;
typedef std::map<std::string, double> resource_batch_t;
struct analytics_state_t {
    std::unique_ptr<const game_session> g_session;
    analytics_status status = INITIALIZING;
    baked_event_queue_t baked_event_queue;
    raw_event_queue_t raw_event_queue;
    canceller_t terminate_worker{false};
    action_queue syncronized_actions;
    resource_batch_t resource_batch;
    std::condition_variable cond;
    std::mutex mut;
    void set_game_session(const game_session & session){
        std::lock_guard<std::mutex> guard(mut);
        g_session.reset(new game_session(session));
    }
};

std::unique_ptr<analytics_state_t> analytics_state;

std::string Base64Encode(const unsigned char * in, size_t len) { //Encodes a binary safe base 64 string
    BIO *bio, *b64;
    BUF_MEM *bufferPtr;

    b64 = BIO_new(BIO_f_base64());
    bio = BIO_new(BIO_s_mem());
    bio = BIO_push(b64, bio);
//    std::cout << len << std::endl;
    BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL); //Ignore newlines - write everything in one line
    BIO_write(bio, in, len);
    (void)BIO_flush(bio);
    BIO_get_mem_ptr(bio, &bufferPtr);
    std::string result(bufferPtr->data, bufferPtr->length);
    BIO_free_all(b64);

    return std::move(result); //success
}

void print_buf(const char *title, const unsigned char *buf, size_t buf_len)
{
    size_t i = 0;
    fprintf(stdout, "%s\n", title);
    for(i = 0; i < buf_len; ++i)
    fprintf(stdout, "%02X%s", buf[i],
             ( i + 1 ) % 16 == 0 ? "\r\n" : " " );
}

//def hmac_hash_with_secret(message, key):
//    return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest())
std::string hmac_hash_with_secret(const char * message, size_t msg_len, const char * key) {
    typedef const unsigned char * cucp;
    unsigned char md[EVP_MAX_MD_SIZE];
    unsigned int md_len;
    HMAC(EVP_sha256(), (cucp) key, std::strlen(key), (cucp) message, msg_len, md, &md_len);
 //   print_buf("hmac", md, md_len);
    return Base64Encode(md, md_len);
}

// This function returns a seeming valid gzip string but gameanalytics.com doesn't accept it :/
// The generated string is very similar to the one generated by the REST_v2_example.py but not
// exactly the same, so maybe the solution is through tweaking deflateInit2 below.
std::string get_gzip_string(const char * message, size_t message_len) {
    z_stream defstream;
    defstream.zalloc = Z_NULL;
    defstream.zfree = Z_NULL;
    defstream.opaque = Z_NULL;
    defstream.next_in = (unsigned char *)message;
    defstream.avail_in = message_len;

    int windowBits = 15;
    int GZIP_ENCODING = 16;

    auto ret = deflateInit2(&defstream, Z_DEFAULT_COMPRESSION, Z_DEFLATED,
                  windowBits | GZIP_ENCODING,
                  8,
                  Z_DEFAULT_STRATEGY);
    orxASSERT(ret == Z_OK);

    auto dest_len = deflateBound(&defstream, message_len);
    std::vector<char> buffer(dest_len);
    defstream.next_out = (unsigned char *)buffer.data();
    defstream.avail_out = dest_len;

    ret = deflate(&defstream, Z_FINISH);
    orxASSERT(ret == Z_STREAM_END);

    ret = deflateEnd(&defstream);
    orxASSERT(ret == Z_OK);

    return {buffer.data(), size_t(defstream.next_out - (unsigned char *) buffer.data())};
}

headers_t get_gameanalytics_headers(const char * payload, size_t len, bool gzipped = false) {
    headers_t result = {
        {"Authorization", hmac_hash_with_secret(payload, len, secret_key)},
        {"Content-Type", "application/json"},
        {"Content-Length", to_string(len)}
    };
    if(gzipped) result["Content-Encoding"] = "gzip";
    return result;
}

enum response_type {
    OK, ERROR, TIMEOUT
};

struct init_result {
    response_type type;
    orxS64 ts_offset;
};

init_result request_init(const platform_info & platform, int timeout, canceller_t * canceller) {
    Json init_payload = Json::object {
        {"platform", platform.platform_name},
        {"os_version", platform.os_version},
        {"sdk_version", sdk_version}
    };
    auto init_payload_str = init_payload.dump();

    auto headers = get_gameanalytics_headers(init_payload_str.c_str(), init_payload_str.size());
    auto init_resp = post(url_init(), init_payload_str, headers, timeout, canceller);
    std::cout << init_resp.response_code << ": " << init_resp.response << std::endl;

    if(init_resp.response_code == -1) return {TIMEOUT,0};

    if(init_resp.response_code != 200) return {ERROR, 0};

    std::string err;
    auto init_json = Json::parse(init_resp.response, err);

    Json enabled = init_json["enabled"];
    if(!enabled.is_bool() || !enabled.bool_value()) return {ERROR, 0};

    Json server_ts = init_json["server_ts"];
    if(!server_ts.is_number()) return {ERROR, 0};
    double server_ts_val = server_ts.number_value();

    return {OK, orxS64(server_ts_val - orxSystem_GetRealTime())};
}

constexpr char analytics_prefix_ptr[] = "Analytics/";

const char * get_analytics_section(const char * subname) {
    return Persist(join("", analytics_prefix_ptr, subname).c_str());
}

const char * getAnalyticsFile() {
    return orxFile_GetApplicationSaveDirectory("analytics.ini");
}

void persist_analytics() {
    orxConfig_Save(getAnalyticsFile(), false, pick_with_prefix<analytics_prefix_ptr>);
}

void load_analytics() {
    orxConfig_Load(getAnalyticsFile());
}

std::thread * worker;

void init_analytics() {
    load_analytics();

    auto platform = GetPlatform()->getPlatformInfo();

    {
        ConfigSectionGuard guard("PlatformInfo");
        orxConfig_SetString("UserID", platform.user_id.c_str());
        orxConfig_SetString("OSVer", platform.os_version.c_str());
    }

    analytics_state.reset(new analytics_state_t);
    analytics_state->status = INITIALIZING;

    if(orxConfig_GetBool("IsPendingEndEvent")) {
        analytics_state->baked_event_queue.push_back(orxConfigX_GetJson("PendingEndEvent"));
    }

    worker = new std::thread(analytics_worker, platform);
}

void start_analytics_session() {
    ConfigSectionGuard guard(get_analytics_section("Session"));

    orxU64 session_num;
    if(orxConfig_HasValue("Num")) {
        auto last_session_num = orxConfig_GetU64("Num");
        session_num = last_session_num+1;
    } else session_num = 1;

    orxConfig_SetU64("Num", session_num);

    auto now = std::chrono::high_resolution_clock::now().time_since_epoch();
    boost::mt19937 ran;
    uint32_t microseconds = std::chrono::duration_cast<std::chrono::microseconds>(now).count();
    ran.seed(microseconds);

    auto session_id = to_string(boost::uuids::random_generator(&ran)());

    std::string custom_01 = GetValue<std::string>("LiveConfig", "Version");
    auto build_desc = GetValue<std::string>("BuildInfo", "Description");

    game_session g_session = {session_id, session_num, orxSystem_GetRealTime(), custom_01, build_desc};

    analytics_state->set_game_session(g_session);

    persist_analytics();

    analytics_state->cond.notify_all();
}

void update_analytics() {
    action_queue actions;
    {
        std::lock_guard<std::mutex> l_guard(analytics_state->mut);
        ConfigSectionGuard c_guard("AnalyticsStateWidget");
        orxConfig_SetString("String", analytics_state->status == INITIALIZING   ? "Analytics Initializing" :
                                      analytics_state->status == ACTIVE         ? "Analytics Active" :
                                      analytics_state->status == DISABLED       ? "Analytics Disabled" :
                                      /*analytics_state->status == DISCONNECTED*/ "Analytics Disconnected");
        std::swap(actions, analytics_state->syncronized_actions);
    }
    for(auto & action: actions) action();
}

void exit_analytics() {
    {
        std::lock_guard<std::mutex> l_guard(analytics_state->mut);
        analytics_state->terminate_worker = true;
    }
    analytics_state->cond.notify_all();
    worker->join();
    delete worker;
    for(auto & action: analytics_state->syncronized_actions) action();
}

baked_event bake_event(const analytics_session & a_session, const raw_event & r_event, const platform_info & platform) {
    Json::object common_fields = {
            {"v", 2},
            {"sdk_version", sdk_version},
            {"user_id", platform.user_id},
            {"os_version", platform.os_version},
            {"manufacturer", platform.manufacturer},
            {"device", platform.device_name},
            {"platform", platform.platform_name},
            {"session_id", r_event.session.session_id},
            {"session_num", double(r_event.session.session_num)},
            {"custom_01", r_event.session.custom_01},
            {"client_ts", double(r_event.details.unadjusted_ts + a_session.ts_offset)},
            {"build", r_event.session.build_desc.substr(0, 32)},
    };
    common_fields.insert(r_event.details.details.begin(), r_event.details.details.end());
    return common_fields;
}

void add_to_raw_event_queue(Json::object details, bool push_front = false, orxU64 unadjusted_ts = orxSystem_GetRealTime()) {
    raw_event event {*analytics_state->g_session, {unadjusted_ts, std::move(details)}};
    std::lock_guard<std::mutex> l_guard(analytics_state->mut);
    if(push_front) {
        auto it = analytics_state->raw_event_queue.begin();
        analytics_state->raw_event_queue.insert(it, event);
    } else analytics_state->raw_event_queue.push_back(event);
}

void add_to_baked_event_queue(baked_event event) {
    std::lock_guard<std::mutex> l_guard(analytics_state->mut);
    analytics_state->baked_event_queue.push_back(event);
}

void session_start_event() { add_to_raw_event_queue({{"category", "user"}}, true);}
baked_event create_session_end_event(const analytics_session & a_session, const platform_info & platform, const game_session & g_session) {
    Json::object details = {
        {"category", "session_end"},
        {"length", double(orxSystem_GetRealTime() - g_session.local_session_start_ts)}
    };
    raw_event event {g_session, {orxSystem_GetRealTime(), std::move(details)}};
    return bake_event(a_session, event, platform);
}

void process_resource_batch(const resource_batch_t & batch) {
    for(auto & resource: batch) {
        add_to_raw_event_queue({
            {"category", "resource"},
            {"event_id", resource.first},
            {"amount", resource.second}
        });
    }
}

bool submit_events(const analytics_session & a_session, const platform_info & platform, int timeout = -1, canceller_t * canceller = nullptr) {
    resource_batch_t batch; {
        std::lock_guard<std::mutex> l_guard(analytics_state->mut);
        std::swap(batch, analytics_state->resource_batch);
    }

    process_resource_batch(batch);

    baked_event_queue_t baked_events;
    raw_event_queue_t raw_events;
    {
        std::lock_guard<std::mutex> l_guard(analytics_state->mut);
        std::swap(baked_events, analytics_state->baked_event_queue);
        std::swap(raw_events, analytics_state->raw_event_queue);
    }
    for(auto & r_event: raw_events) {
        baked_events.push_back(bake_event(a_session, r_event, platform));
    }

    if(baked_events.empty()) return true;

    std::string events_str = Json(baked_events).dump();

//    The following don't work with gameanalytics.com, see the explanation in get_gzip_string
//    auto payload = get_gzip_string(events_str.c_str(), events_str.size());
//    auto headers = get_gameanalytics_headers(payload.c_str(), payload.size(), true);
//    auto response = post(url_events(), payload, headers);

    auto headers = get_gameanalytics_headers(events_str.c_str(), events_str.size());
    auto response = post(url_events(), events_str, headers, timeout, canceller);

    std::cout << "Sending: " << events_str << std::endl;
    std::cout << response.response_code << ": " << response.response << std::endl;

    if(response.response_code == 200) return true;
    else {
        std::lock_guard<std::mutex> l_guard(analytics_state->mut);
        baked_events.insert(baked_events.end(), analytics_state->baked_event_queue.begin(), analytics_state->baked_event_queue.end());
        std::swap(baked_events, analytics_state->baked_event_queue);
        return false;
    }
}

void analytics_worker(platform_info platform) {

    bool terminate = false;

    auto sleep = [&](int timeout) {
        std::unique_lock<std::mutex> l_guard(analytics_state->mut);
        if(analytics_state->terminate_worker) return true;
        analytics_state->cond.wait_for(l_guard, std::chrono::seconds(timeout));
        return (bool)analytics_state->terminate_worker;
    };

    init_result resp;
    do {
        resp = request_init(platform, -1, &analytics_state->terminate_worker);
        if(resp.type == ERROR) {
            {
                std::lock_guard<std::mutex> l_guard(analytics_state->mut);
                analytics_state->status = DISABLED;
            }
            return;
        }
        if(resp.type == TIMEOUT) {
            {
                std::lock_guard<std::mutex> l_guard(analytics_state->mut);
                analytics_state->status = DISCONNECTED;
            }
            terminate = sleep(3);
            if(terminate) return;
        }
    } while(resp.type != OK);
    analytics_session a_session{resp.ts_offset};

    {
        std::unique_lock<std::mutex> l_guard(analytics_state->mut);
        while(!analytics_state->g_session) {
            if(analytics_state->terminate_worker) return;
            analytics_state->cond.wait(l_guard);
            if(analytics_state->terminate_worker) return;
        }
    }

    session_start_event();

    auto make_end_event = [&] {
        return create_session_end_event(a_session, platform, *analytics_state->g_session);
    };

    auto persist_end_event = [](baked_event event) {
        std::lock_guard<std::mutex> l_guard(analytics_state->mut);
        analytics_state->syncronized_actions.push_back([event](){
            ConfigSectionGuard c_guard(get_analytics_section("Session"));
            orxConfig_SetBool("IsPendingEndEvent", true);
            orxConfigX_SetJson("PendingEndEvent", event);
            persist_analytics();
        });
    };

    bool submitted_session_start = false;
    while(!terminate) {
        if(submit_events(a_session, platform, -1, &analytics_state->terminate_worker)) {
            {
                std::lock_guard<std::mutex> l_guard(analytics_state->mut);
                analytics_state->status = ACTIVE;
            }
            submitted_session_start = true;
            persist_end_event(make_end_event());
            terminate = sleep(20);
        } else {
            {
                std::lock_guard<std::mutex> l_guard(analytics_state->mut);
                analytics_state->status = DISCONNECTED;
            }
            if(submitted_session_start) persist_end_event(make_end_event());
            terminate = sleep(3);
        }
    }

    auto end_event = make_end_event();
    add_to_baked_event_queue(end_event);
    if(submit_events(a_session, platform, 1)) {
        std::lock_guard<std::mutex> l_guard(analytics_state->mut);
        analytics_state->syncronized_actions.push_back([](){
            ConfigSectionGuard c_guard(get_analytics_section("Session"));
            orxConfig_SetBool("IsPendingEndEvent", false);
            persist_analytics();
        });
    } else {
        persist_end_event(end_event);
    }
}

void progression_event(progression_event_type type, const char* level, int score) {
    Json::object details {{"category", "progression"}};

    const char * type_str = type==P_START    ? "Start" :
                            type==P_COMPLETE ? "Complete" :
                            /*type==P_FAIL*/   "Fail";
    details["event_id"] = join(":", type_str, level);

    ConfigSectionGuard guard(get_analytics_section(level));
    orxU32 attempt_num = orxConfig_GetU32("AttemptNum");

    if(type == P_COMPLETE || type == P_FAIL) {
        details["attempt_num"] = double(attempt_num);
        details["score"] = score;
    }

    switch (type) {
    case P_COMPLETE:
        orxConfig_ClearValue("AttemptNum");
        persist_analytics();
        break;
    case P_START:
        orxConfig_SetU32("AttemptNum", attempt_num + 1);
        persist_analytics();
        break;
    case P_FAIL:
        break;
    }
    add_to_raw_event_queue(details);
}

void resource_event(resource_event_type type, double amount,
        const char* currency, const char* itemType, const char* itemId) {
    auto type_str = type == R_SINK ? "Sink" : "Source";
    auto event_id = join(":", type_str, currency, itemType, itemId);
    {
        std::lock_guard<std::mutex> l_guard(analytics_state->mut);
        analytics_state->resource_batch[event_id] += amount;
    }
}

void design_event(const std::vector<const char*>& fields) {
    orxASSERT(fields.size());
    std::stringstream ss;
    ss << fields[0];
    for(size_t i=1; i<fields.size(); i++) ss << ":" << fields[i];
    add_to_raw_event_queue(Json::object {
        {"category", "design"},
        {"event_id", ss.str()}
    });
}
